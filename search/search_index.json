{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Grazel \u00b6 Grazel stands for Gradle to Bazel . It is a Gradle plugin that enables you to migrate Android projects to Bazel build system in an incremental and automated fashion. How it works \u00b6 It works by automatically generating Bazel scripts for given Android project based on your Gradle configuration. For simple projects, it should be able to migrate, fully build and launch the app with bazel mobile-install //<target-name> . For example, for the following Gradle configuration: apply plugin: \"com.android.library\" apply plugin: \"kotlin-android\" android { compileSdkVersion rootProject . compileSdk defaultConfig { minSdkVersion rootProject . minSdk targetSdkVersion rootProject . targetSdk versionCode 1 versionName \"1.0\" } } dependencies { implementation project ( \":app\" ) implementation project ( \":base\" ) implementation \"androidx.test.espresso:espresso-idling-resource:3.2.0\" } Grazel's migrateToBazel task generates the following Bazel build script: load ( \"@io_bazel_rules_kotlin//kotlin:kotlin.bzl\" , \"kt_android_library\" ) kt_android_library ( name = \"quiz\" , srcs = glob ([ \"src/main/java/**/*.kt\" , ]), custom_package = \"com.google.samples.apps.topeka.quiz\" , manifest = \"src/main/AndroidManifest.xml\" , resource_files = glob ([ \"src/main/res/**\" , ]), visibility = [ \"//visibility:public\" , ], deps = [ \"//app\" , \"//base\" , \"@maven//:androidx_test_espresso_espresso_idling_resource\" , ], ) See migration capabilities for supported features. In advanced cases, where entire project might not be migratable , it migrates part of the graph and sets up hybrid build where part of the graph can be built with Bazel and rest with Gradle. Components \u00b6 Gradle plugin A Kotlin Starlark DSL to generate Starlark code in a type-safe way. Grab Bazel Common - Custom rules to bridge the gap between Gradle/Bazel. Features \u00b6 Generate BUILD.bazel , WORKSPACE for given Android project and reduce the overall migration effort. Setup hybrid build to build part of project graph to build with Bazel and rest with Gradle. Minimal source changes to codebase - supported by Grab Bazel Common . Gradle Configuration as source of truth. Getting Started \u00b6 Requirements \u00b6 Buildifier is installed and avaialble in the path. Mac Install via homebrew . brew install buildifier Linux Install via apt and npm . sudo apt-get install nodejs npm npm i -g @bazel/buildifier Apply Grazel plugin \u00b6 Grazel is available on Maven Central. In root build.gradle : buildscript { repositories { mavenCentral () } dependencies { classpath \"com.grab.grazel:grazel-gradle-plugin:0.1.0\" } } apply plugin: \"com.grab.grazel\" // Grazel configuration grazel { // DSL } Note Grazel registers migrateToBazel lifecycle task that can be used to generate Bazel build scripts. By default, it filters out modules based on a set of migration criteria and generates scripts only for supported modules. To run Grazel, execute ./gradlew migrateToBazel For more advanced configuration options, see Configuration . License \u00b6 Copyright 2021 Grabtaxi Holdings PTE LTE (GRAB) Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#grazel","text":"Grazel stands for Gradle to Bazel . It is a Gradle plugin that enables you to migrate Android projects to Bazel build system in an incremental and automated fashion.","title":"Grazel"},{"location":"#how-it-works","text":"It works by automatically generating Bazel scripts for given Android project based on your Gradle configuration. For simple projects, it should be able to migrate, fully build and launch the app with bazel mobile-install //<target-name> . For example, for the following Gradle configuration: apply plugin: \"com.android.library\" apply plugin: \"kotlin-android\" android { compileSdkVersion rootProject . compileSdk defaultConfig { minSdkVersion rootProject . minSdk targetSdkVersion rootProject . targetSdk versionCode 1 versionName \"1.0\" } } dependencies { implementation project ( \":app\" ) implementation project ( \":base\" ) implementation \"androidx.test.espresso:espresso-idling-resource:3.2.0\" } Grazel's migrateToBazel task generates the following Bazel build script: load ( \"@io_bazel_rules_kotlin//kotlin:kotlin.bzl\" , \"kt_android_library\" ) kt_android_library ( name = \"quiz\" , srcs = glob ([ \"src/main/java/**/*.kt\" , ]), custom_package = \"com.google.samples.apps.topeka.quiz\" , manifest = \"src/main/AndroidManifest.xml\" , resource_files = glob ([ \"src/main/res/**\" , ]), visibility = [ \"//visibility:public\" , ], deps = [ \"//app\" , \"//base\" , \"@maven//:androidx_test_espresso_espresso_idling_resource\" , ], ) See migration capabilities for supported features. In advanced cases, where entire project might not be migratable , it migrates part of the graph and sets up hybrid build where part of the graph can be built with Bazel and rest with Gradle.","title":"How it works"},{"location":"#components","text":"Gradle plugin A Kotlin Starlark DSL to generate Starlark code in a type-safe way. Grab Bazel Common - Custom rules to bridge the gap between Gradle/Bazel.","title":"Components"},{"location":"#features","text":"Generate BUILD.bazel , WORKSPACE for given Android project and reduce the overall migration effort. Setup hybrid build to build part of project graph to build with Bazel and rest with Gradle. Minimal source changes to codebase - supported by Grab Bazel Common . Gradle Configuration as source of truth.","title":"Features"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#requirements","text":"Buildifier is installed and avaialble in the path. Mac Install via homebrew . brew install buildifier Linux Install via apt and npm . sudo apt-get install nodejs npm npm i -g @bazel/buildifier","title":"Requirements"},{"location":"#apply-grazel-plugin","text":"Grazel is available on Maven Central. In root build.gradle : buildscript { repositories { mavenCentral () } dependencies { classpath \"com.grab.grazel:grazel-gradle-plugin:0.1.0\" } } apply plugin: \"com.grab.grazel\" // Grazel configuration grazel { // DSL } Note Grazel registers migrateToBazel lifecycle task that can be used to generate Bazel build scripts. By default, it filters out modules based on a set of migration criteria and generates scripts only for supported modules. To run Grazel, execute ./gradlew migrateToBazel For more advanced configuration options, see Configuration .","title":"Apply Grazel plugin"},{"location":"#license","text":"Copyright 2021 Grabtaxi Holdings PTE LTE (GRAB) Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"bazel_configuration/","text":"Bazel Configuration \u00b6 Once Grazel's migrateToBazel generates Bazel scripts, bazel can be used to run the build. Additional configuration files are required for optimal builds and currently Grazel does not generate these (may change in the future). Recommended usage is via bazelisk which is wrapper for bazel similar to gradlew for gradle . .bazelrc \u00b6 .bazelrc is used to specifiy additional properties and flags to Bazel similar to gradle.properties . A basic configuration is given below but it may vary depending on project needs. # Disk cache build -- disk_cache = bazel - cache # Env config build -- incompatible_strict_action_env build -- incompatible_disable_depset_items # Error config build -- verbose_failures # D8 and Dexing flags build -- define = android_incremental_dexing_tool = d8_dexbuilder build -- define = android_standalone_dexing_tool = d8_compat_dx build -- nouse_workers_with_dexbuilder build -- strategy = Desugar = sandboxed # Databinding flags build -- experimental_android_databinding_v2 build -- android_databinding_use_v3_4_args build -- android_databinding_use_androidx # Flags to enable latest android providers in rules build -- experimental_google_legacy_api query -- experimental_google_legacy_api build -- strict_java_deps = off # Turn off strict java deps (when databinding enabled) # Resource Workers # build --persistent_android_resource_processor # Disabled due to resource merging error (when databinding enabled) build -- strategy = AARGenerator = standalone # https://github.com/bazelbuild/bazel/issues/9207#issuecomment-522727482 # Java Workers build -- strategy = KotlinCompile = worker build -- strategy = Javac = worker .bazelversion \u00b6 4.1.0 Used to specify the bazel version that will be used to build the project. Used by bazelisk . Custom Android Tools \u00b6 Grazel also ships patched Android tools used in bazel as part of grab-bazel-common to fix few performance and build related issues. See patches for more info.","title":"Bazel"},{"location":"bazel_configuration/#bazel-configuration","text":"Once Grazel's migrateToBazel generates Bazel scripts, bazel can be used to run the build. Additional configuration files are required for optimal builds and currently Grazel does not generate these (may change in the future). Recommended usage is via bazelisk which is wrapper for bazel similar to gradlew for gradle .","title":"Bazel Configuration"},{"location":"bazel_configuration/#bazelrc","text":".bazelrc is used to specifiy additional properties and flags to Bazel similar to gradle.properties . A basic configuration is given below but it may vary depending on project needs. # Disk cache build -- disk_cache = bazel - cache # Env config build -- incompatible_strict_action_env build -- incompatible_disable_depset_items # Error config build -- verbose_failures # D8 and Dexing flags build -- define = android_incremental_dexing_tool = d8_dexbuilder build -- define = android_standalone_dexing_tool = d8_compat_dx build -- nouse_workers_with_dexbuilder build -- strategy = Desugar = sandboxed # Databinding flags build -- experimental_android_databinding_v2 build -- android_databinding_use_v3_4_args build -- android_databinding_use_androidx # Flags to enable latest android providers in rules build -- experimental_google_legacy_api query -- experimental_google_legacy_api build -- strict_java_deps = off # Turn off strict java deps (when databinding enabled) # Resource Workers # build --persistent_android_resource_processor # Disabled due to resource merging error (when databinding enabled) build -- strategy = AARGenerator = standalone # https://github.com/bazelbuild/bazel/issues/9207#issuecomment-522727482 # Java Workers build -- strategy = KotlinCompile = worker build -- strategy = Javac = worker","title":".bazelrc"},{"location":"bazel_configuration/#bazelversion","text":"4.1.0 Used to specify the bazel version that will be used to build the project. Used by bazelisk .","title":".bazelversion"},{"location":"bazel_configuration/#custom-android-tools","text":"Grazel also ships patched Android tools used in bazel as part of grab-bazel-common to fix few performance and build related issues. See patches for more info.","title":"Custom Android Tools"},{"location":"databinding/","text":"Kotlin Databinding Support \u00b6 TBA","title":"Databinding"},{"location":"databinding/#kotlin-databinding-support","text":"TBA","title":"Kotlin Databinding Support"},{"location":"gradle_tasks/","text":"Gradle Tasks \u00b6 Grazel gradle plugin does not do any major configuration during Gradle's Configuration phase with the exception of hybrid builds . Most of the work for migration is moved to execution phase via the following Gradle tasks. All the tasks are available under task group bazel . Tasks \u00b6 migrateToBazel \u00b6 migrateToBazel is a lifecycle task that simply depends on relevant migration tasks and serves as the entry point to Grazel execution. This task should be preferred over individual tasks since this wires up the task graph correctly and needed tasks are run. generateBazelScripts \u00b6 Attached to every project instance, this task is responsible for generating BUILD.bazel for the given module. The task checks if a module can be migrated and proceeds to generate the script. If not, it renames BUILD.bazel to BUILD.bazelignore when module becomes unmigrateable. generateRootBazelScripts \u00b6 Attached to root project, this task generates BUILD.bazel and WORKPSACE files. formatBazelScripts \u00b6 Depends on generateBazelScripts and responsible for formatting the generated file with buildifier . formatBuildBazel and formatWorkSpace depends on generateRootBazelScripts to format root project's Bazel scripts. Task Graph \u00b6 The task graph allows project's migration tasks to run in parallel to increase migrateToBazel performance.","title":"Gradle Tasks"},{"location":"gradle_tasks/#gradle-tasks","text":"Grazel gradle plugin does not do any major configuration during Gradle's Configuration phase with the exception of hybrid builds . Most of the work for migration is moved to execution phase via the following Gradle tasks. All the tasks are available under task group bazel .","title":"Gradle Tasks"},{"location":"gradle_tasks/#tasks","text":"","title":"Tasks"},{"location":"gradle_tasks/#migratetobazel","text":"migrateToBazel is a lifecycle task that simply depends on relevant migration tasks and serves as the entry point to Grazel execution. This task should be preferred over individual tasks since this wires up the task graph correctly and needed tasks are run.","title":"migrateToBazel"},{"location":"gradle_tasks/#generatebazelscripts","text":"Attached to every project instance, this task is responsible for generating BUILD.bazel for the given module. The task checks if a module can be migrated and proceeds to generate the script. If not, it renames BUILD.bazel to BUILD.bazelignore when module becomes unmigrateable.","title":"generateBazelScripts"},{"location":"gradle_tasks/#generaterootbazelscripts","text":"Attached to root project, this task generates BUILD.bazel and WORKPSACE files.","title":"generateRootBazelScripts"},{"location":"gradle_tasks/#formatbazelscripts","text":"Depends on generateBazelScripts and responsible for formatting the generated file with buildifier . formatBuildBazel and formatWorkSpace depends on generateRootBazelScripts to format root project's Bazel scripts.","title":"formatBazelScripts"},{"location":"gradle_tasks/#task-graph","text":"The task graph allows project's migration tasks to run in parallel to increase migrateToBazel performance.","title":"Task Graph"},{"location":"grazel_extension/","text":"Grazel Extension \u00b6 Grazel aims to infer most of the project data from Gradle and ships with sensible defaults for migration. However it is also configurable via Gradle extensions based on project needs. Configuring Grazel Extension \u00b6 Use the registered grazel extension block in root build.gradle to configure Grazel grazel { // Configuration } Android Extension \u00b6 Configures options for Android targets grazel { android { dexShards = 10 // Controls android_binary's dex_shards property https://docs.bazel.build/versions/main/be/android.html#android_binary.dex_shards multiDexEnabled = true // default `true` variantFilter { variant -> variant . setIgnore ( variant . name != \"debug\" && variant . name != \"flavor1Debug\" ) } features { dataBinding = true } } ... } Variant Filter \u00b6 Currently Grazel supports migrating only one variant. variantFilter {} can be used to specify the variants that should be excluded. In case the variant filter is not supplied or filter allows more than one variant, Grazel will still generate a single Bazel target by merging all the source sets in which case build might fail with duplicate classes error. Databinding \u00b6 By default, all modules that use databinding are excluded from migration since Bazel's Android databinding support is an ongoing effort , especially for Kotlin. Setting dataBinding to true will migrate the project using Grab's custom macro . See databinding for more info. Dependencies \u00b6 Grazel uses Gradle's dependencies resolution data to generate Bazel dependencies information. This block can be used to control how dependencies are read or override Gradle information in generated code. grazel { dependencies { ///... } } Override versions \u00b6 Grazel will use the provided artifact version instead of using Gradle data. grazel { dependencies { ignoreArtifacts . add ( \"com.unsupported.dependency\" ) overrideArtifactVersions . add ( \"androidx.preference:preference:1.1.0\" ) } } Example Here even though Gradle uses androidx.preference:preference:1.1.1 , due to overrideArtifactVersions the generated maven_install rule will contain version 1.1.0 . Ignore artifacts \u00b6 Bazel's rules_jvm_external does not support all of Gradle's supported repositories such as AWS or private Maven repositories with auth headers. ignoreArtifacts can be used to exclude certain dependencies from migration. Warning Any module that uses any of the ignored artifacts will be excluded from migration to not fail the build during dependency resolution by maven_install rule. Rules \u00b6 Rules block can be used to configure various rules that are used by Grazel in generated scripts. grazel { rules { // Rules configuration. } } Bazel Common \u00b6 Grazel uses Grab Bazel Common to implement Gradle features in Bazel that are not readily available in Bazel. For example, build config fields or res values . grazel { rules { bazelCommon { gitRepository { commit = \"f74ef90479383a38cef1af33d28a3253031e00c1\" // Commit hash remote = \"https://github.com/grab/grab-bazel-common.git\" } } } } gitRepository or httpRepository can be used to configure the WORKPSACE repository target that will be generated. Example For example, the above configuration will generate the following. load ( \"@bazel_tools//tools/build_defs/repo:git.bzl\" , \"git_repository\" ) git_repository ( name = \"grab_bazel_common\" , commit = \"f74ef90479383a38cef1af33d28a3253031e00c1\" , remote = \"https://github.com/grab/grab-bazel-common.git\" , ) Kotlin \u00b6 Configure options for rules_kotlin . rules { kotlin { // WORKSPACE gitRepository { commit = \"eae21653baad4b403fee9e8a706c9d4fbd0c27c6\" remote = \"https://github.com/bazelbuild/rules_kotlin.git\" } // WORKSPACE compiler { version = \"1.4.20\" sha = \"46720991a716e90bfc0cf3f2c81b2bd735c14f4ea6a5064c488e04fd76e6b6c7\" } // https://bazelbuild.github.io/rules_kotlin/kotlin#kt_kotlinc_options kotlinC { useIr = false } // https://bazelbuild.github.io/rules_kotlin/kotlin#define_kt_toolchain toolchain { enabled = true apiVersion = \"1.4\" reportUnusedDeps = \"off\" strictKotlinDeps = \"off\" abiJars = true multiplexWorkers = true languageVersion = \"1.4\" jvmTarget = \"1.8\" } } } Maven Install \u00b6 Grazel uses official rules_jvm_external to resolve maven dependencies. Maven install extension is used to configure options for maven_install rule. grazel { rules { bazelCommon { mavenInstall { resolveTimeout = 1000 // https://github.com/bazelbuild/rules_jvm_external#fetch-and-resolve-timeout excludeArtifacts . add ( \"androidx.test.espresso:espresso-contrib\" ) jetifyIncludeList . add ( \"com.android.support:cardview-v7\" ) jetifyExcludeList . add ( \"androidx.appcompat:appcompat\" ) } } } } Exclude artifacts \u00b6 Control globally excluded artifacts as specified here . This can be used to filter out unsupported dependencies or dependencies that have issues resolving with mavenInstall . This does not affect a module's migration criteria . Jetifier \u00b6 Jetifier is automatically detected by looking for presence of android.enableJetifier in gradle.properties . Configure options for Jetifier . jetifyIncludeList - Configure artifacts that should be included for Jetification. jetifyIncludeList - Configure artifacts that should be excluded from Jetification. With these options, Grazel generates jetify_include_list as specified here with the formula jetify_include_list = (allArtifacts + jetifyIncludeList) - jetifyIncludeList","title":"Grazel Extension"},{"location":"grazel_extension/#grazel-extension","text":"Grazel aims to infer most of the project data from Gradle and ships with sensible defaults for migration. However it is also configurable via Gradle extensions based on project needs.","title":"Grazel Extension"},{"location":"grazel_extension/#configuring-grazel-extension","text":"Use the registered grazel extension block in root build.gradle to configure Grazel grazel { // Configuration }","title":"Configuring Grazel Extension"},{"location":"grazel_extension/#android-extension","text":"Configures options for Android targets grazel { android { dexShards = 10 // Controls android_binary's dex_shards property https://docs.bazel.build/versions/main/be/android.html#android_binary.dex_shards multiDexEnabled = true // default `true` variantFilter { variant -> variant . setIgnore ( variant . name != \"debug\" && variant . name != \"flavor1Debug\" ) } features { dataBinding = true } } ... }","title":"Android Extension"},{"location":"grazel_extension/#variant-filter","text":"Currently Grazel supports migrating only one variant. variantFilter {} can be used to specify the variants that should be excluded. In case the variant filter is not supplied or filter allows more than one variant, Grazel will still generate a single Bazel target by merging all the source sets in which case build might fail with duplicate classes error.","title":"Variant Filter"},{"location":"grazel_extension/#databinding","text":"By default, all modules that use databinding are excluded from migration since Bazel's Android databinding support is an ongoing effort , especially for Kotlin. Setting dataBinding to true will migrate the project using Grab's custom macro . See databinding for more info.","title":"Databinding"},{"location":"grazel_extension/#dependencies","text":"Grazel uses Gradle's dependencies resolution data to generate Bazel dependencies information. This block can be used to control how dependencies are read or override Gradle information in generated code. grazel { dependencies { ///... } }","title":"Dependencies"},{"location":"grazel_extension/#override-versions","text":"Grazel will use the provided artifact version instead of using Gradle data. grazel { dependencies { ignoreArtifacts . add ( \"com.unsupported.dependency\" ) overrideArtifactVersions . add ( \"androidx.preference:preference:1.1.0\" ) } } Example Here even though Gradle uses androidx.preference:preference:1.1.1 , due to overrideArtifactVersions the generated maven_install rule will contain version 1.1.0 .","title":"Override versions"},{"location":"grazel_extension/#ignore-artifacts","text":"Bazel's rules_jvm_external does not support all of Gradle's supported repositories such as AWS or private Maven repositories with auth headers. ignoreArtifacts can be used to exclude certain dependencies from migration. Warning Any module that uses any of the ignored artifacts will be excluded from migration to not fail the build during dependency resolution by maven_install rule.","title":"Ignore artifacts"},{"location":"grazel_extension/#rules","text":"Rules block can be used to configure various rules that are used by Grazel in generated scripts. grazel { rules { // Rules configuration. } }","title":"Rules"},{"location":"grazel_extension/#bazel-common","text":"Grazel uses Grab Bazel Common to implement Gradle features in Bazel that are not readily available in Bazel. For example, build config fields or res values . grazel { rules { bazelCommon { gitRepository { commit = \"f74ef90479383a38cef1af33d28a3253031e00c1\" // Commit hash remote = \"https://github.com/grab/grab-bazel-common.git\" } } } } gitRepository or httpRepository can be used to configure the WORKPSACE repository target that will be generated. Example For example, the above configuration will generate the following. load ( \"@bazel_tools//tools/build_defs/repo:git.bzl\" , \"git_repository\" ) git_repository ( name = \"grab_bazel_common\" , commit = \"f74ef90479383a38cef1af33d28a3253031e00c1\" , remote = \"https://github.com/grab/grab-bazel-common.git\" , )","title":"Bazel Common"},{"location":"grazel_extension/#kotlin","text":"Configure options for rules_kotlin . rules { kotlin { // WORKSPACE gitRepository { commit = \"eae21653baad4b403fee9e8a706c9d4fbd0c27c6\" remote = \"https://github.com/bazelbuild/rules_kotlin.git\" } // WORKSPACE compiler { version = \"1.4.20\" sha = \"46720991a716e90bfc0cf3f2c81b2bd735c14f4ea6a5064c488e04fd76e6b6c7\" } // https://bazelbuild.github.io/rules_kotlin/kotlin#kt_kotlinc_options kotlinC { useIr = false } // https://bazelbuild.github.io/rules_kotlin/kotlin#define_kt_toolchain toolchain { enabled = true apiVersion = \"1.4\" reportUnusedDeps = \"off\" strictKotlinDeps = \"off\" abiJars = true multiplexWorkers = true languageVersion = \"1.4\" jvmTarget = \"1.8\" } } }","title":"Kotlin"},{"location":"grazel_extension/#maven-install","text":"Grazel uses official rules_jvm_external to resolve maven dependencies. Maven install extension is used to configure options for maven_install rule. grazel { rules { bazelCommon { mavenInstall { resolveTimeout = 1000 // https://github.com/bazelbuild/rules_jvm_external#fetch-and-resolve-timeout excludeArtifacts . add ( \"androidx.test.espresso:espresso-contrib\" ) jetifyIncludeList . add ( \"com.android.support:cardview-v7\" ) jetifyExcludeList . add ( \"androidx.appcompat:appcompat\" ) } } } }","title":"Maven Install"},{"location":"grazel_extension/#exclude-artifacts","text":"Control globally excluded artifacts as specified here . This can be used to filter out unsupported dependencies or dependencies that have issues resolving with mavenInstall . This does not affect a module's migration criteria .","title":"Exclude artifacts"},{"location":"grazel_extension/#jetifier","text":"Jetifier is automatically detected by looking for presence of android.enableJetifier in gradle.properties . Configure options for Jetifier . jetifyIncludeList - Configure artifacts that should be included for Jetification. jetifyIncludeList - Configure artifacts that should be excluded from Jetification. With these options, Grazel generates jetify_include_list as specified here with the formula jetify_include_list = (allArtifacts + jetifyIncludeList) - jetifyIncludeList","title":"Jetifier"},{"location":"hybrid_builds/","text":"Hybrid build \u00b6 Hybrid builds were implemented in response to dealing with large module graphs in a project and not all of them would be migratable or requires much refactoring effort to make them build with both the build systems. Hybrid builds helps in performing incremental migrations on large projects where one shot migration might not possible. It works in tandem with Migration Criteria and builds only part of the dependency graph with Bazel and ensures remaining graph nodes are built with Gradle while consuming artifacts built by Gradle. How it works \u00b6 During Gradle's configuration phase, Grazel does bazelisk build //... on the project directory to build all targets. This action would generate build artifacts like .jar or .aar in the configuration phase. Then Grazel sets up dependency substitution rules on the entire dependency graph such that during resolution if Grazel finds an build artifact for a project, it removes the project dependency and replaces it with the built artifact. Doing this process on the entire graph lets the execution phase use prebuilt artifacts by Bazel in the part of the graph and rest with Gradle. Run Hybrid builds \u00b6 Hybrid builds can be triggered by settting bazelEnabled boolean property in either local.properties or gradle.properties . Then when building any gradle module like app:assembleDebug , Grazel would build and register substitution rules. Substitution rules occur lazily and only when configuration it is replacing dependency of is needed in current build. Debugging \u00b6 To perform dependency substitution, Grazel relies on strong naming conventions. If there is a module called :quiz , then the corresponding artifact that would be searched for would be quiz.aar and quiz.jar . During build to debug whether substituions are happening correctly look for Dependency Substitution table in build logs as shown below. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 :app \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Configuration \u2502 Project \u2502Substitution Artifacts\u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502implementation\u2502:quiz \u2502[quiz.aar] \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502implementation\u2502:base \u2502[base.aar] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Error Note that when a build artifact for a module can't be found, Grazel fails the build. This is to ensure every module that has BUILD.bazel is able to build successfully","title":"Hybrid Builds"},{"location":"hybrid_builds/#hybrid-build","text":"Hybrid builds were implemented in response to dealing with large module graphs in a project and not all of them would be migratable or requires much refactoring effort to make them build with both the build systems. Hybrid builds helps in performing incremental migrations on large projects where one shot migration might not possible. It works in tandem with Migration Criteria and builds only part of the dependency graph with Bazel and ensures remaining graph nodes are built with Gradle while consuming artifacts built by Gradle.","title":"Hybrid build"},{"location":"hybrid_builds/#how-it-works","text":"During Gradle's configuration phase, Grazel does bazelisk build //... on the project directory to build all targets. This action would generate build artifacts like .jar or .aar in the configuration phase. Then Grazel sets up dependency substitution rules on the entire dependency graph such that during resolution if Grazel finds an build artifact for a project, it removes the project dependency and replaces it with the built artifact. Doing this process on the entire graph lets the execution phase use prebuilt artifacts by Bazel in the part of the graph and rest with Gradle.","title":"How it works"},{"location":"hybrid_builds/#run-hybrid-builds","text":"Hybrid builds can be triggered by settting bazelEnabled boolean property in either local.properties or gradle.properties . Then when building any gradle module like app:assembleDebug , Grazel would build and register substitution rules. Substitution rules occur lazily and only when configuration it is replacing dependency of is needed in current build.","title":"Run Hybrid builds"},{"location":"hybrid_builds/#debugging","text":"To perform dependency substitution, Grazel relies on strong naming conventions. If there is a module called :quiz , then the corresponding artifact that would be searched for would be quiz.aar and quiz.jar . During build to debug whether substituions are happening correctly look for Dependency Substitution table in build logs as shown below. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 :app \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502Configuration \u2502 Project \u2502Substitution Artifacts\u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502implementation\u2502:quiz \u2502[quiz.aar] \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502implementation\u2502:base \u2502[base.aar] \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Error Note that when a build artifact for a module can't be found, Grazel fails the build. This is to ensure every module that has BUILD.bazel is able to build successfully","title":"Debugging"},{"location":"migration_capabilities/","text":"Migration Capabilities \u00b6 Grazel uses a combination of automation (script generation) and custom Bazel rules to successfully migrate a project and to ensure both Gradle and Bazel can function together. Android configuration \u00b6 Grazel automatically infers Android configuration via Gradle extensions and generates corresponding rules in WORKSPACE and in generated andorid_library or android_binary targets. These include (but not limited to): Variant aware Kotlin/Java source sets Variant aware assets/resources source sets Manifest placeholders Manifest files Custom keystore files specified via signingConfigs.storeFile Multidex configs Compile, Min, Target SDK versions Build tools version Jetified artifacts Build config fields - via build_config String resource values - via res_value Google Play Services Crashlytics - via tools_android Dagger - via dagger_rules Kotlin Parcelize support - via parcelize_rules Databinding - via grab-bazel-common Known unsupported features Annotation processors - Planned Test targets - Planned Local aar files - Planned Dependencies \u00b6 Grazel generates rules_jvm_external rules to resove dependencies. Versions \u00b6 During migration, Grazel performs Gradle's dependency resolution instead of simply using what's declared on build.gradle before generating final artifact coordinates in Bazel scripts (i.e maven_install ). This is done to ensure Bazel uses the same dependency version that is being used by the app at the runtime. The has the following advantages: Gradle Configuration 's resolution strategy, forced modules and substitutions are supported. Actual resolved version of the dependency is generated for maven_install rule. Detect supported artifacts for migration. See repositories . Dependency Graph aware \u00b6 Grazel captures module dependency graph and generates deps field in generated rules. For example, when app depends on project(\":quiz\") , Grazel would generate quiz/BUILD.bazel if quiz can be successfully migrated and then add //quiz in app 's android_library/android_binary target. In any case, quiz is not migrateable , then app or any other module that depends on quiz won't be migrated. Note Currently Grazel does not support api configuration well. For example, if quiz has api project(':home') . Modules dependent on quiz will not see home in Bazel. This can be manually fixed by add exports = [\"//home\"] to //quiz target. Maven artifact repositories \u00b6 While Grazel is capable of generating correct @maven://artifact_coordinate targets which are Bazel's version of configuration 'artifact_coordinate' , Bazel's official rules_jvm_external does not support all types of Maven repositories. Currently supported repository types are Public Maven repositories Private Maven repositories authenticated by basic auth Other types of Maven repositories such as AWS or private Maven with auth headers are not supported. Warning Grazel automatically detects dependencies from unsupported repositories and any module that uses these dependencies will be excluded from migration. In any case, if the project has unsupported or unresolvable dependencies, combination of exclude artifacts and ignore artifacts can be used to get a partial successful build. Java/Koltin modules \u00b6 In addition to Android modules, pure Kotlin or Java modules are supported. Grazel infers srcs and deps from Gradle source sets/extensions and generates corresponding kt_jvm_library or java_library . Kotlin Toolchain \u00b6 Grazel generates rules_kotlin scripts and provides configuration to generate define_kt_toolchain in root BUILD.bazel . The toolchain adds ability to toggle specific rules_kotlin features like multiplex workers, langugage version and ABI jars. ABI jars in particular brings considerable incremental build performance due to compile avoidance on non ABI changes. Currently Kotlin toolchain values are not auto inferred and needs to be manually specified although this may change in the future.","title":"Migration Capabilities"},{"location":"migration_capabilities/#migration-capabilities","text":"Grazel uses a combination of automation (script generation) and custom Bazel rules to successfully migrate a project and to ensure both Gradle and Bazel can function together.","title":"Migration Capabilities"},{"location":"migration_capabilities/#android-configuration","text":"Grazel automatically infers Android configuration via Gradle extensions and generates corresponding rules in WORKSPACE and in generated andorid_library or android_binary targets. These include (but not limited to): Variant aware Kotlin/Java source sets Variant aware assets/resources source sets Manifest placeholders Manifest files Custom keystore files specified via signingConfigs.storeFile Multidex configs Compile, Min, Target SDK versions Build tools version Jetified artifacts Build config fields - via build_config String resource values - via res_value Google Play Services Crashlytics - via tools_android Dagger - via dagger_rules Kotlin Parcelize support - via parcelize_rules Databinding - via grab-bazel-common Known unsupported features Annotation processors - Planned Test targets - Planned Local aar files - Planned","title":"Android configuration"},{"location":"migration_capabilities/#dependencies","text":"Grazel generates rules_jvm_external rules to resove dependencies.","title":"Dependencies"},{"location":"migration_capabilities/#versions","text":"During migration, Grazel performs Gradle's dependency resolution instead of simply using what's declared on build.gradle before generating final artifact coordinates in Bazel scripts (i.e maven_install ). This is done to ensure Bazel uses the same dependency version that is being used by the app at the runtime. The has the following advantages: Gradle Configuration 's resolution strategy, forced modules and substitutions are supported. Actual resolved version of the dependency is generated for maven_install rule. Detect supported artifacts for migration. See repositories .","title":"Versions"},{"location":"migration_capabilities/#dependency-graph-aware","text":"Grazel captures module dependency graph and generates deps field in generated rules. For example, when app depends on project(\":quiz\") , Grazel would generate quiz/BUILD.bazel if quiz can be successfully migrated and then add //quiz in app 's android_library/android_binary target. In any case, quiz is not migrateable , then app or any other module that depends on quiz won't be migrated. Note Currently Grazel does not support api configuration well. For example, if quiz has api project(':home') . Modules dependent on quiz will not see home in Bazel. This can be manually fixed by add exports = [\"//home\"] to //quiz target.","title":"Dependency Graph aware"},{"location":"migration_capabilities/#maven-artifact-repositories","text":"While Grazel is capable of generating correct @maven://artifact_coordinate targets which are Bazel's version of configuration 'artifact_coordinate' , Bazel's official rules_jvm_external does not support all types of Maven repositories. Currently supported repository types are Public Maven repositories Private Maven repositories authenticated by basic auth Other types of Maven repositories such as AWS or private Maven with auth headers are not supported. Warning Grazel automatically detects dependencies from unsupported repositories and any module that uses these dependencies will be excluded from migration. In any case, if the project has unsupported or unresolvable dependencies, combination of exclude artifacts and ignore artifacts can be used to get a partial successful build.","title":"Maven artifact repositories"},{"location":"migration_capabilities/#javakoltin-modules","text":"In addition to Android modules, pure Kotlin or Java modules are supported. Grazel infers srcs and deps from Gradle source sets/extensions and generates corresponding kt_jvm_library or java_library .","title":"Java/Koltin modules"},{"location":"migration_capabilities/#kotlin-toolchain","text":"Grazel generates rules_kotlin scripts and provides configuration to generate define_kt_toolchain in root BUILD.bazel . The toolchain adds ability to toggle specific rules_kotlin features like multiplex workers, langugage version and ABI jars. ABI jars in particular brings considerable incremental build performance due to compile avoidance on non ABI changes. Currently Kotlin toolchain values are not auto inferred and needs to be manually specified although this may change in the future.","title":"Kotlin Toolchain"},{"location":"migration_criteria/","text":"Migration Criteria \u00b6 Grazel was designed acknowledging the fact that migrating all possible combinations of Gradle project might be a difficult problem to solve. Instead it operates by knowing its own limitations on what can and cannot be migrated to Bazel. It does this by establishing various MigrationCriteria . Every module is run through set of predefined MigrationCriteria and is checked for compatibility. Only modules that pass the criteria are selected for migration, and then induced subgraphs of those modules are migrated to bazel i.e generate bazel scripts. Criteria \u00b6 Sample Criteria \u00b6 Let's consider a sample crtierion that a module should be Android, Kotlin or Java project to be eligible for migration. @Singleton internal class PluginsMigrationCriteria @Inject constructor () : MigrationCriteria { override fun canMigrate ( project : Project ): Boolean { return project . isAndroid || project . isJava || project . isKotlin } } This criteria is evaluated together with other criteria and then final graph for migration is calculated. This approach enables Grazel to do incremental migrations . Predefined criteria \u00b6 Android, Java or Kotlin plugin is applied to the module A module's dependencies are all resolved from supported Maven repositories. Details . Note The pre-existing criteria were designed keeping Grab's app in mind. It might need to be expanded depending on project configuration. If you encounter such issues, please let us know. User defined criteria \u00b6 Few migration critera are configurable via Grazel extensions. Databinding - Android project using databinding/viewbinding are not migrated by default. The android extension can be used to change that. Ignored artifacts - A module that uses any of the artifacts that ignored in dependencies extension are not migrated. Contribute custom criteria \u00b6 A module passing migration criterria means that it can be safely built with Bazel. Due to missing checks it is possible a module was migrated but build fails. In that case the migration criteria needs to be updated or a new check needs to be added to prevent build failures. To do that, start by implementing MigrationCriteria interface. @Singleton internal class CustomMigrationCriteria @Inject constructor () : MigrationCriteria { override fun canMigrate ( project : Project ): Boolean { return // Custom checks } } Add the criteria to set to let Grazel pick up the condition. @ElementsIntoSet @Provides fun migrationCriteria ( //... customMigrationCriteria : CustomMigrationCriteria ): Set < MigrationCriteria > = setOf ( //... customMigrationCriteria ) Incremental Migration \u00b6 Through use of migration criteria, Grazel can do incremental migrations where initially supported modules can be migrated. Then by increasing Grazel's feature set or by custom rules, the migration criteria can be widened to cover more modules. For validations on these partial migrations, Grazel can also setup hybrid builds to assert these changes. Forward Compatible \u00b6 Validating against migration crtieria helps in letting changes generated by Grazel to be forward compatible. This means since Gradle is always source of truth for the duration of migration, any feature changes changes in Gradle can be synced with Bazel simply by running migrateToBazel . This is particularly helpful in earlier stages of migration where not a lot of modules could be migrated and feature development was causing lot of graph changes. Migration Workflow \u00b6 Migration workflow with Grazel could look like below. This way 100% compatible build can be acheived while having defined results along the way.","title":"Migration Criteria and Workflow"},{"location":"migration_criteria/#migration-criteria","text":"Grazel was designed acknowledging the fact that migrating all possible combinations of Gradle project might be a difficult problem to solve. Instead it operates by knowing its own limitations on what can and cannot be migrated to Bazel. It does this by establishing various MigrationCriteria . Every module is run through set of predefined MigrationCriteria and is checked for compatibility. Only modules that pass the criteria are selected for migration, and then induced subgraphs of those modules are migrated to bazel i.e generate bazel scripts.","title":"Migration Criteria"},{"location":"migration_criteria/#criteria","text":"","title":"Criteria"},{"location":"migration_criteria/#sample-criteria","text":"Let's consider a sample crtierion that a module should be Android, Kotlin or Java project to be eligible for migration. @Singleton internal class PluginsMigrationCriteria @Inject constructor () : MigrationCriteria { override fun canMigrate ( project : Project ): Boolean { return project . isAndroid || project . isJava || project . isKotlin } } This criteria is evaluated together with other criteria and then final graph for migration is calculated. This approach enables Grazel to do incremental migrations .","title":"Sample Criteria"},{"location":"migration_criteria/#predefined-criteria","text":"Android, Java or Kotlin plugin is applied to the module A module's dependencies are all resolved from supported Maven repositories. Details . Note The pre-existing criteria were designed keeping Grab's app in mind. It might need to be expanded depending on project configuration. If you encounter such issues, please let us know.","title":"Predefined criteria"},{"location":"migration_criteria/#user-defined-criteria","text":"Few migration critera are configurable via Grazel extensions. Databinding - Android project using databinding/viewbinding are not migrated by default. The android extension can be used to change that. Ignored artifacts - A module that uses any of the artifacts that ignored in dependencies extension are not migrated.","title":"User defined criteria"},{"location":"migration_criteria/#contribute-custom-criteria","text":"A module passing migration criterria means that it can be safely built with Bazel. Due to missing checks it is possible a module was migrated but build fails. In that case the migration criteria needs to be updated or a new check needs to be added to prevent build failures. To do that, start by implementing MigrationCriteria interface. @Singleton internal class CustomMigrationCriteria @Inject constructor () : MigrationCriteria { override fun canMigrate ( project : Project ): Boolean { return // Custom checks } } Add the criteria to set to let Grazel pick up the condition. @ElementsIntoSet @Provides fun migrationCriteria ( //... customMigrationCriteria : CustomMigrationCriteria ): Set < MigrationCriteria > = setOf ( //... customMigrationCriteria )","title":"Contribute custom criteria"},{"location":"migration_criteria/#incremental-migration","text":"Through use of migration criteria, Grazel can do incremental migrations where initially supported modules can be migrated. Then by increasing Grazel's feature set or by custom rules, the migration criteria can be widened to cover more modules. For validations on these partial migrations, Grazel can also setup hybrid builds to assert these changes.","title":"Incremental Migration"},{"location":"migration_criteria/#forward-compatible","text":"Validating against migration crtieria helps in letting changes generated by Grazel to be forward compatible. This means since Gradle is always source of truth for the duration of migration, any feature changes changes in Gradle can be synced with Bazel simply by running migrateToBazel . This is particularly helpful in earlier stages of migration where not a lot of modules could be migrated and feature development was causing lot of graph changes.","title":"Forward Compatible"},{"location":"migration_criteria/#migration-workflow","text":"Migration workflow with Grazel could look like below. This way 100% compatible build can be acheived while having defined results along the way.","title":"Migration Workflow"}]}